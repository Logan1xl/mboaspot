package com.example.backend.services.implementations;

import com.example.backend.dto.*;
import com.example.backend.entities.*;
import com.example.backend.exceptions.ResourceNotFoundException;
import com.example.backend.repositories.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;
import java.util.stream.Collectors;

@Service
@Transactional
public class AnnonceService {

    @Autowired
    private AnnoncesRepository annoncesRepository;

    @Autowired
    private DisponibiliteRepository disponibiliteRepository;

    @Autowired
    private LocalisationRepository localisationRepository;

    @Autowired
    private ProprietaireRepository proprietaireRepository;

    // ===== CRUD Annonces =====

    /**
     * Créer une annonce avec disponibilité par défaut
     */
    public AnnonceResponseDTO creerAnnonce(AnnonceRequestDTO request) {
        // Vérifier que le propriétaire existe
        Proprietaire proprietaire = proprietaireRepository.findById(request.getProprietaireId())
                .orElseThrow(() -> new RuntimeException("Propriétaire non trouvé"));

        // Créer l'annonce
        Annonces annonce = new Annonces();
        annonce.setTitre(request.getTitre());
        annonce.setPrix(request.getPrix());
        annonce.setAdresse(request.getAdresse());
        annonce.setVille(request.getVille());
        annonce.setNbreChambres(request.getNbreChambres());
        annonce.setNbreLits(request.getNbreLits());
        annonce.setMaxInvites(request.getMaxInvites());
        annonce.setDescription(request.getDescription());
        annonce.setTypeAnnonce(request.getTypeAnnonce());
        annonce.setIdProprietaire(proprietaire);
        annonce.setEstActive(true);  // Active par défaut
        annonce.setEvaluationMoyenne(0.0);
        annonce.setTotalAvis(0);

        // Si latitude/longitude fournies dans la requête
        if (request.getLatitude() != null) {
            annonce.setLatitude(request.getLatitude());
        }
        if (request.getLongitude() != null) {
            annonce.setLongitude(request.getLongitude());
        }

        annonce = annoncesRepository.save(annonce);

        // Créer la localisation si ville et quartier sont fournis
        if (request.getVille() != null) {
            Localisation localisation = new Localisation();
            localisation.setVille(request.getVille());
            localisation.setQuartier(request.getQuartier() != null ? request.getQuartier() : "Centre");
            localisation.setLatitude(request.getLatitude());
            localisation.setLongitude(request.getLongitude());
            localisation.setIdAnnonce(annonce);
            localisationRepository.save(localisation);
        }

        // Créer une disponibilité par défaut (1 an)
        creerDisponibiliteParDefaut(annonce);

        return convertirEnResponseDTO(annonce);
    }

    /**
     * Créer une annonce à partir d'un AnnonceDTO complet
     */
    public AnnonceDTO createAnnonce(AnnonceDTO dto) {
        Annonces annonce = convertToEntity(dto);
        annonce.setEstActive(true);
        annonce.setEvaluationMoyenne(0.0);
        annonce.setTotalAvis(0);

        Annonces saved = annoncesRepository.save(annonce);

        // Créer la localisation si fournie
        if (dto.getLocalisation() != null) {
            LocalisationDTO locDTO = dto.getLocalisation();
            Localisation localisation = new Localisation();
            localisation.setVille(locDTO.getVille());
            localisation.setQuartier(locDTO.getQuartier());
            localisation.setLatitude(locDTO.getLatitude());
            localisation.setLongitude(locDTO.getLongitude());
            localisation.setIdAnnonce(saved);
            localisationRepository.save(localisation);
        }

        // Créer disponibilité par défaut
        creerDisponibiliteParDefaut(saved);

        return convertToDTO(saved);
    }

    /**
     * Obtenir toutes les annonces
     */
    public List<AnnonceDTO> getAllAnnonces() {
        return annoncesRepository.findAll()
                .stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    /**
     * Obtenir une annonce par ID
     */
    public AnnonceResponseDTO obtenirAnnonce(Long id) {
        Annonces annonce = annoncesRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Annonce non trouvée"));
        return convertirEnResponseDTO(annonce);
    }

    /**
     * Obtenir une annonce par ID (version DTO)
     */
    public Optional<AnnonceDTO> getAnnonceById(Long id) {
        return annoncesRepository.findById(id)
                .map(this::convertToDTO);
    }

    /**
     * Obtenir toutes les annonces actives
     */
    public List<AnnonceResponseDTO> obtenirAnnoncesActives() {
        List<Annonces> annonces = annoncesRepository.findByEstActive(true);
        return annonces.stream()
                .map(this::convertirEnResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Obtenir les annonces actives (version DTO)
     */
    public List<AnnonceDTO> getAnnoncesActives() {
        return annoncesRepository.findAll()
                .stream()
                .filter(a -> a.getEstActive() != null && a.getEstActive())
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    /**
     * Obtenir les annonces d'un propriétaire
     */
    public List<AnnonceResponseDTO> obtenirAnnoncesProprietaire(Long proprietaireId) {
        List<Annonces> annonces = annoncesRepository.findByIdProprietaire_Id(proprietaireId);
        return annonces.stream()
                .map(this::convertirEnResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Mettre à jour une annonce
     */
    public AnnonceResponseDTO mettreAJourAnnonce(Long id, AnnonceRequestDTO request) {
        Annonces annonce = annoncesRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Annonce non trouvée"));

        // Mettre à jour les champs
        annonce.setTitre(request.getTitre());
        annonce.setPrix(request.getPrix());
        annonce.setAdresse(request.getAdresse());
        annonce.setVille(request.getVille());
        annonce.setNbreChambres(request.getNbreChambres());
        annonce.setNbreLits(request.getNbreLits());
        annonce.setMaxInvites(request.getMaxInvites());
        annonce.setDescription(request.getDescription());
        annonce.setTypeAnnonce(request.getTypeAnnonce());

        annonce = annoncesRepository.save(annonce);

        return convertirEnResponseDTO(annonce);
    }

    /**
     * Mettre à jour une annonce (version DTO)
     */
    public AnnonceDTO updateAnnonce(Long id, AnnonceDTO dto) {
        Annonces annonce = annoncesRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Annonce non trouvée"));

        // Mise à jour des champs
        annonce.setTitre(dto.getTitre());
        annonce.setPrix(dto.getPrix());
        annonce.setAdresse(dto.getAdresse());
        annonce.setLatitude(dto.getLatitude());
        annonce.setLongitude(dto.getLongitude());
        annonce.setVille(dto.getVille());
        annonce.setNbreChambres(dto.getNbreChambres());
        annonce.setNbreLits(dto.getNbreLits());
        annonce.setMaxInvites(dto.getMaxInvites());
        annonce.setDescription(dto.getDescription());
        annonce.setTypeAnnonce(dto.getTypeAnnonce());
        annonce.setUrlImagePrincipale(dto.getUrlImagePrincipale());

        if (dto.getUrlImages() != null) {
            annonce.setUrlImages(String.join(",", dto.getUrlImages()));
        }

        Annonces updated = annoncesRepository.save(annonce);
        return convertToDTO(updated);
    }

    /**
     * Changer le statut d'une annonce (activer/désactiver)
     */
    public AnnonceResponseDTO changerStatutAnnonce(Long id, Boolean estActive) {
        Annonces annonce = annoncesRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Annonce non trouvée"));

        annonce.setEstActive(estActive);
        annonce = annoncesRepository.save(annonce);

        return convertirEnResponseDTO(annonce);
    }

    /**
     * Activer/désactiver une annonce
     */
    public void activerAnnonce(Long id, Boolean activer) {
        Annonces annonce = annoncesRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Annonce non trouvée"));
        annonce.setEstActive(activer);
        annoncesRepository.save(annonce);
    }

    /**
     * Supprimer (désactiver) une annonce
     */
    public void supprimerAnnonce(Long id) {
        Annonces annonce = annoncesRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Annonce non trouvée"));

        // Désactiver au lieu de supprimer
        annonce.setEstActive(false);
        annoncesRepository.save(annonce);
    }

    /**
     * Supprimer définitivement une annonce
     */
    public void deleteAnnonce(Long id) {
        annoncesRepository.deleteById(id);
    }

    // ===== Recherche avancée =====

    public List<AnnonceDTO> rechercherAnnonces(RechercheDTO recherche) {
        List<Annonces> resultats;

        if (recherche.getLatitude() != null && recherche.getLongitude() != null && recherche.getRayon() != null) {
            // Recherche par géolocalisation
            resultats = annoncesRepository.findAnnoncesProches(
                    recherche.getLatitude(),
                    recherche.getLongitude(),
                    recherche.getRayon()
            );
        } else {
            // Recherche par critères
            resultats = annoncesRepository.rechercheAvancee(
                    recherche.getVille(),
                    recherche.getTypeAnnonce(),
                    recherche.getPrixMin(),
                    recherche.getPrixMax(),
                    recherche.getNbreChambres(),
                    recherche.getEvaluationMin()
            );
        }

        return resultats.stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    public List<AnnonceDTO> getTopAnnonces() {
        return annoncesRepository.findTop10ByEstActiveTrueOrderByEvaluationMoyenneDesc()
                .stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }

    public List<String> getVillesDisponibles() {
        return localisationRepository.findAllVilles();
    }

    public List<String> getQuartiersByVille(String ville) {
        return localisationRepository.findQuartiersByVille(ville);
    }

    // ===== Gestion Disponibilité =====

    public List<DisponibiliteDTO> getDisponibilites(Long annonceId) {
        return disponibiliteRepository.findByIdAnnonceId(annonceId)
                .stream()
                .map(this::convertDisponibiliteToDTO)
                .collect(Collectors.toList());
    }

    public DisponibiliteDTO addDisponibilite(DisponibiliteDTO dto) {
        Annonces annonce = annoncesRepository.findById(dto.getIdAnnonce())
                .orElseThrow(() -> new RuntimeException("Annonce non trouvée"));

        Disponibilite dispo = new Disponibilite();
        dispo.setEstDisponible(dto.getEstDisponible());
        dispo.setPrixSurcharge(dto.getPrixSurcharge());
        dispo.setDateDebut(dto.getDateDebut());
        dispo.setDateFin(dto.getDateFin());
        dispo.setIdAnnonce(annonce);

        Disponibilite saved = disponibiliteRepository.save(dispo);
        return convertDisponibiliteToDTO(saved);
    }

    public boolean verifierDisponibilite(Long annonceId, Date dateDebut, Date dateFin) {
        List<Disponibilite> dispos = disponibiliteRepository.findDisponibilitePourPeriode(
                annonceId, dateDebut, dateFin
        );
        return !dispos.isEmpty();
    }

    // ===== Gestion Localisation =====

    public Optional<LocalisationDTO> getLocalisation(Long annonceId) {
        return localisationRepository.findByIdAnnonceId(annonceId)
                .map(this::convertLocalisationToDTO);
    }

    public LocalisationDTO updateLocalisation(Long annonceId, LocalisationDTO dto) {
        Annonces annonce = annoncesRepository.findById(annonceId)
                .orElseThrow(() -> new RuntimeException("Annonce non trouvée"));

        Localisation localisation = localisationRepository.findByIdAnnonceId(annonceId)
                .orElse(new Localisation());

        localisation.setVille(dto.getVille());
        localisation.setQuartier(dto.getQuartier());
        localisation.setLatitude(dto.getLatitude());
        localisation.setLongitude(dto.getLongitude());
        localisation.setIdAnnonce(annonce);

        Localisation saved = localisationRepository.save(localisation);
        return convertLocalisationToDTO(saved);
    }

    // ===== Méthodes utilitaires privées =====

    private void creerDisponibiliteParDefaut(Annonces annonce) {
        Disponibilite disponibilite = new Disponibilite();
        disponibilite.setIdAnnonce(annonce);
        disponibilite.setDateDebut(new Date());  // Aujourd'hui

        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.YEAR, 1);  // +1 an
        disponibilite.setDateFin(cal.getTime());

        disponibilite.setEstDisponible(true);
        disponibilite.setPrixSurcharge(0.0);

        disponibiliteRepository.save(disponibilite);
    }

    private AnnonceResponseDTO convertirEnResponseDTO(Annonces annonce) {
        AnnonceResponseDTO dto = new AnnonceResponseDTO();

        dto.setId(annonce.getId());
        dto.setTitre(annonce.getTitre());
        dto.setPrix(annonce.getPrix());
        dto.setAdresse(annonce.getAdresse());
        dto.setVille(annonce.getVille());
        dto.setNbreChambres(annonce.getNbreChambres());
        dto.setNbreLits(annonce.getNbreLits());
        dto.setMaxInvites(annonce.getMaxInvites());
        dto.setDescription(annonce.getDescription());
        dto.setTypeAnnonce(annonce.getTypeAnnonce());
        dto.setEstActive(annonce.getEstActive());
        dto.setEvaluationMoyenne(annonce.getEvaluationMoyenne());
        dto.setTotalAvis(annonce.getTotalAvis());
        dto.setUrlImagePrincipale(annonce.getUrlImagePrincipale());

        // Infos du propriétaire
        dto.setProprietaireId(annonce.getIdProprietaire().getId());
        dto.setProprietaireNom(annonce.getIdProprietaire().getNomEntreprise());

        return dto;
    }

    private AnnonceDTO convertToDTO(Annonces annonce) {
        AnnonceDTO dto = new AnnonceDTO();
        dto.setId(annonce.getId());
        dto.setTitre(annonce.getTitre());
        dto.setPrix(annonce.getPrix());
        dto.setAdresse(annonce.getAdresse());
        dto.setLatitude(annonce.getLatitude());
        dto.setLongitude(annonce.getLongitude());
        dto.setVille(annonce.getVille());
        dto.setNbreChambres(annonce.getNbreChambres());
        dto.setNbreLits(annonce.getNbreLits());
        dto.setMaxInvites(annonce.getMaxInvites());
        dto.setDescription(annonce.getDescription());
        dto.setEstActive(annonce.getEstActive());
        dto.setEvaluationMoyenne(annonce.getEvaluationMoyenne());
        dto.setTotalAvis(annonce.getTotalAvis());
        dto.setUrlImagePrincipale(annonce.getUrlImagePrincipale());
        dto.setTypeAnnonce(annonce.getTypeAnnonce());

        if (annonce.getUrlImages() != null) {
            dto.setUrlImages(Arrays.asList(annonce.getUrlImages().split(",")));
        }

        if (annonce.getIdProprietaire() != null) {
            dto.setIdProprietaire(annonce.getIdProprietaire().getId());
            if (annonce.getIdProprietaire().getIdUser() != null) {
                dto.setProprietaireNom(annonce.getIdProprietaire().getIdUser().getNom());
            }
        }

        return dto;
    }

    private Annonces convertToEntity(AnnonceDTO dto) {
        Annonces annonce = new Annonces();
        annonce.setTitre(dto.getTitre());
        annonce.setPrix(dto.getPrix());
        annonce.setAdresse(dto.getAdresse());
        annonce.setLatitude(dto.getLatitude());
        annonce.setLongitude(dto.getLongitude());
        annonce.setVille(dto.getVille());
        annonce.setNbreChambres(dto.getNbreChambres());
        annonce.setNbreLits(dto.getNbreLits());
        annonce.setMaxInvites(dto.getMaxInvites());
        annonce.setDescription(dto.getDescription());
        annonce.setTypeAnnonce(dto.getTypeAnnonce());
        annonce.setUrlImagePrincipale(dto.getUrlImagePrincipale());

        if (dto.getUrlImages() != null) {
            annonce.setUrlImages(String.join(",", dto.getUrlImages()));
        }

        if (dto.getIdProprietaire() != null) {
            Proprietaire proprio = proprietaireRepository.findById(dto.getIdProprietaire())
                    .orElseThrow(() -> new RuntimeException("Propriétaire non trouvé"));
            annonce.setIdProprietaire(proprio);
        }

        return annonce;
    }

    private DisponibiliteDTO convertDisponibiliteToDTO(Disponibilite dispo) {
        DisponibiliteDTO dto = new DisponibiliteDTO();
        dto.setId(dispo.getId());
        dto.setEstDisponible(dispo.getEstDisponible());
        dto.setPrixSurcharge(dispo.getPrixSurcharge());
        dto.setDateDebut(dispo.getDateDebut());
        dto.setDateFin(dispo.getDateFin());
        dto.setIdAnnonce(dispo.getIdAnnonce().getId());
        return dto;
    }

    private LocalisationDTO convertLocalisationToDTO(Localisation loc) {
        LocalisationDTO dto = new LocalisationDTO();
        dto.setId(loc.getId());
        dto.setVille(loc.getVille());
        dto.setQuartier(loc.getQuartier());
        dto.setLatitude(loc.getLatitude());
        dto.setLongitude(loc.getLongitude());
        dto.setIdAnnonce(loc.getIdAnnonce());
        return dto;
    }
}package com.example.backend.services.implementations;



import com.example.backend.entities.*;
import com.example.backend.dto.AuthResponseDTO;
import com.example.backend.dto.LoginDTO;
import com.example.backend.dto.RegisterDTO;
import com.example.backend.repositories.AdminRepository;
import com.example.backend.repositories.*;
import com.example.backend.roles.RoleUtilisateur;
import com.example.backend.security.jwt.JwtUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class AuthService {

    @Autowired
    private UtilisateurRepository userRepository;

    @Autowired
    private VoyageurRepository voyageurRepository;

    @Autowired
    private ProprietaireRepository proprietaireRepository;

    @Autowired
    private AdminRepository adminRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private JwtUtils jwtUtils;

    @Transactional
    public AuthResponseDTO register(RegisterDTO dto) {

        if (userRepository.existsByEmail(dto.getEmail())) {
            throw new RuntimeException("Cet email est déjà utilisé");
        }

        Utilisateur user = new Utilisateur();
        user.setNom(dto.getNom());
        user.setPrenom(dto.getPrenom());
        user.setEmail(dto.getEmail());
        user.setMotDePasse(passwordEncoder.encode(dto.getMotDePasse()));
        user.setNumeroTelephone(dto.getNumeroTelephone());
        user.setPhotoProfil(dto.getPhotoProfil());
        user.setRole(RoleUtilisateur.valueOf(dto.getRole()));
        user.setEstActif(true);

        user = userRepository.save(user);

        switch (dto.getRole()) {
            case "VOYAGEUR":
                Voyageur voyageur = new Voyageur();
                voyageur.setIdUser(user);
                voyageur.setPreferences(dto.getPreferences());
                voyageur.setRoleUtilisateur(RoleUtilisateur.VOYAGEUR);
                voyageurRepository.save(voyageur);
                break;

            case "PROPRIETAIRE":
                Proprietaire proprietaire = new Proprietaire();
                proprietaire.setIdUser(user);
                proprietaire.setNomEntreprise(dto.getNomEntreprise());
                proprietaire.setNumeroIdentification(dto.getNumeroIdentification());
                proprietaire.setCompteBancaire(dto.getCompteBancaire());
                proprietaire.setGainsTotal(0.0);
                proprietaire.setTotalAnnonces(0);
                proprietaire.setEvaluationMoyenne(0.0);
                proprietaireRepository.save(proprietaire);
                break;

            case "ADMIN":
                Admin admin = new Admin();
                admin.setIdUser(user);

                adminRepository.save(admin);
                break;

            default:
                throw new RuntimeException("Rôle invalide");
        }

        String token = jwtUtils.generateToken(
                user.getEmail(),
                user.getRole().name(),
                user.getId()
        );

        AuthResponseDTO response = new AuthResponseDTO();
        response.setToken(token);
        response.setUserId(user.getId());
        response.setEmail(user.getEmail());
        response.setNom(user.getNom());
        response.setPrenom(user.getPrenom());
        response.setRole(user.getRole());
        response.setNumeroTelephone(user.getNumeroTelephone());
        response.setPhotoProfil(user.getPhotoProfil());

        return response;
    }

    public AuthResponseDTO login(LoginDTO dto) {

        Utilisateur user = userRepository.findByEmail(dto.getEmail())
                .orElseThrow(() -> new RuntimeException("Email ou mot de passe incorrect"));

        if (!passwordEncoder.matches(dto.getMotDePasse(), user.getMotDePasse())) {
            throw new RuntimeException("Email ou mot de passe incorrect");
        }

        if (user.getEstActif() == null || !user.getEstActif()) {
            throw new RuntimeException("Votre compte est désactivé");
        }

        String token = jwtUtils.generateToken(
                user.getEmail(),
                user.getRole().name(),
                user.getId()
        );

        AuthResponseDTO response = new AuthResponseDTO();
        response.setToken(token);
        response.setUserId(user.getId());
        response.setEmail(user.getEmail());
        response.setNom(user.getNom());
        response.setPrenom(user.getPrenom());
        response.setRole(user.getRole());
        response.setNumeroTelephone(user.getNumeroTelephone());
        response.setPhotoProfil(user.getPhotoProfil());

        return response;
    }
}package com.example.backend.services.implementations;

import com.example.backend.dto.AvisDTO;
import com.example.backend.entities.Avis;
import com.example.backend.mappers.AvisMapper;
import com.example.backend.repositories.AvisRepos;
import com.example.backend.repositories.VoyageurRepos;
import com.example.backend.services.interfaces.AvisInterface;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class AvisService implements AvisInterface {

    private static final Logger logger = LoggerFactory.getLogger(AvisService.class);

    private AvisMapper avisMapper;
    private AvisRepos avisRepos;
    private VoyageurRepos voyageurRepos;

    public AvisService(AvisMapper avisMapper, AvisRepos avisRepos, VoyageurRepos voyageurRepos) {
        this.avisMapper = avisMapper;
        this.avisRepos = avisRepos;
        this.voyageurRepos = voyageurRepos;
    }

    @Override
    public AvisDTO ajouterAvis(AvisDTO avisDTO) {
        logger.info("Tentative d'ajout d'un avis");

        if (avisDTO.getPhotos() == null || avisDTO.getNote() == null
                || !voyageurRepos.existsById(avisDTO.getIdVoyageur().getId())) {

            logger.warn("Ajout avis refusé : photos/note/voyageur manquant");
            throw new IllegalArgumentException("Les photos,le voyageur et la note sont requises.");
        }

        try {
            Avis avis = avisMapper.toEntity(avisDTO);
            Avis savedAvis = avisRepos.save(avis);

            logger.info("Avis ajouté avec succès (id={})", savedAvis.getId());
            return avisMapper.toDTO(savedAvis);

        } catch (Exception e) {
            logger.error("Erreur lors de l'ajout de l'avis", e);
            throw new RuntimeException("Erreur lors de l'ajout de l'avis: " + e.getMessage());
        }
    }

    @Override
    public List<AvisDTO> listerAvis() {
        logger.info("Récupération de la liste des avis");

        return avisRepos.findAll()
                .stream()
                .map(avisMapper::toDTO)
                .collect(Collectors.toList());
    }

    @Override
    public AvisDTO mettreAJourAvis(Long id, AvisDTO avisDTO) {
        logger.info("Mise à jour de l'avis (id={})", id);

        try {
            Avis existingAvis = avisRepos.findById(avisDTO.getId()).orElse(null);

            if (existingAvis != null) {
                existingAvis.setNote(avisDTO.getNote());
                existingAvis.setPhotos(avisDTO.getPhotos());
                existingAvis.setEstSignale(avisDTO.getEstSignale());
                existingAvis.setRaisonSignalement(avisDTO.getRaisonSignalement());

                Avis updatedAvis = avisRepos.save(existingAvis);
                logger.info("Avis mis à jour avec succès (id={})", id);

                return avisMapper.toDTO(updatedAvis);
            } else {
                logger.warn("Avis non trouvé pour mise à jour (id={})", id);
                throw new RuntimeException("Avis non trouvé avec l'id: " + id);
            }

        } catch (Exception e) {
            logger.error("Erreur lors de la mise à jour de l'avis (id={})", id, e);
            throw new RuntimeException("Erreur lors de la mise à jour de l'avis: " + e.getMessage());
        }
    }

    @Override
    public void supprimerAvis(Long id) {
        logger.info("Suppression de l'avis (id={})", id);

        if (avisRepos.existsById(id)) {
            try {
                avisRepos.deleteById(id);
                logger.info("Avis supprimé avec succès (id={})", id);

            } catch (Exception e) {
                logger.error("Erreur lors de la suppression de l'avis (id={})", id, e);
                throw new RuntimeException("Erreur lors de la suppression de l'avis: " + e.getMessage());
            }

        } else {
            logger.warn("Suppression impossible : avis non trouvé (id={})", id);
            throw new RuntimeException("Avis non trouvé avec l'id: " + id);
        }
    }

    @Override
    public AvisDTO obtenirAvisParId(Long id) {
        logger.info("Récupération de l'avis (id={})", id);

        if (avisRepos.existsById(id)) {
            try {
                Avis avis = avisRepos.findById(id).get();
                logger.debug("Avis récupéré : {}", avis);

                return avisMapper.toDTO(avis);

            } catch (Exception e) {
                logger.error("Erreur lors de la récupération de l'avis (id={})", id, e);
                throw new RuntimeException("Erreur lors de la récupération de l'avis: " + e.getMessage());
            }

        } else {
            logger.warn("Avis non trouvé (id={})", id);
            throw new RuntimeException("Avis non trouvé avec l'id: " + id);
        }
    }
}
package com.example.backend.services.implementations;

import com.example.backend.dto.EquipementDTO;
import com.example.backend.entities.Equipement;
import com.example.backend.mappers.EquipementMapper;
import com.example.backend.repositories.EquipementRepository;
import com.example.backend.services.interfaces.EquipementInterface;

import lombok.AllArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collector;
import java.util.stream.Collectors;

/**
 * Implémentation du service de gestion des équipements.
 * Contient la logique métier (services) entre le controller et la couche repository.
 */
@AllArgsConstructor
@Service
public class EquipementService implements EquipementInterface {

    private final EquipementRepository equipementRepository;
    private final EquipementMapper equipementMapper;



    /**
     * Enregistre un nouvel équipement en base.
     *
     * @param equipementDTO DTO contenant les données de l'équipement
     * @return l'équipement enregistré sous forme de DTO
     */
    @Override
    public EquipementDTO save(EquipementDTO equipementDTO) {
       Equipement equipement = equipementMapper.toEntity(equipementDTO);
        Equipement saved = equipementRepository.save(equipement);
        return equipementMapper.toDto(saved);
    }

    /**
     * Récupère tous les équipements enregistrés.
     *
     * @return liste des équipements en DTO
     */
    @Override
    public List<EquipementDTO> getAll() {
        return equipementRepository.findAll()
               .stream()
                .map(equipementMapper::toDto).collect(Collectors.toList());
    }

    /**
     * Récupère un équipement par son ID.
     *
     * @param id identifiant de l’équipement
     * @return Optional contenant le DTO si l'équipement est trouvé
     */
    @Override
    public EquipementDTO getById(Long id) {

        Equipement equipement = equipementRepository.findById(id).get();
        if (equipement==null){
            throw new RuntimeException("Equipement non trouvé");
        }else{
            return equipementMapper.toDto(equipement);
        }
    }

    /**
     * Supprime un équipement via son ID.
     *
     * @param id identifiant de l’équipement
     */
    @Override
    public void deleteById(Long id) {
        equipementRepository.deleteById(id);
    }

    /**
     * Recherche les équipements par type.
     * @return liste des équipements correspondants
     */
    @Override
    public List<EquipementDTO> findByTypes(String nom) {
        List<Equipement> equipements = equipementRepository.findByNom(nom);
        return equipementMapper.toDto(equipements);
    }

    /**
     * Met à jour un équipement existant.
     *
     * @param id identifiant de l'équipement à mettre à jour
     * @param equipementDTO nouvelles données
     * @return DTO de l'équipement mis à jour
     */
    @Override
    public EquipementDTO update(Long id, EquipementDTO equipementDTO) {
        // Reconstruction de l'entité à partir du DTO
        Equipement equipement = equipementMapper.toEntity(equipementDTO);

        // Mise à jour de l'ID pour indiquer qu'on modifie un existant
        equipement.setId(id);

        // Enregistrement en base
        Equipement updatedEquipement = equipementRepository.save(equipement);

        // Retour en DTO
        return equipementMapper.toDto(updatedEquipement);
    }

   
    
    @Override
    public Optional<EquipementDTO> getEquipementById(Long id) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'getEquipementById'");
    }

    @Override
    public List<EquipementDTO> getAllEquipements() {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'getAllEquipements'");
    }

    @Override
    public EquipementDTO updateEquipement(Long id, EquipementDTO equipementDTO) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'updateEquipement'");
    }

    @Override
    public void deleteEquipement(Long id) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'deleteEquipement'");
    }

    @Override
    public void delete(Long id) {
        // Vérifie si l'équipement existe avant de supprimer (optionnel mais recommandé)
        if (!equipementRepository.existsById(id)) {
            throw new RuntimeException("Équipement non trouvé avec l'id : " + id);
        }
        equipementRepository.deleteById(id);
    }

}

package com.example.backend.services.implementations;

import com.example.backend.dto.FavoriDTO;
import com.example.backend.entities.Favori;
import com.example.backend.mappers.FavoriMapper;
import com.example.backend.repositories.AnnoncesRepos;
import com.example.backend.repositories.FavoriRepos;
import com.example.backend.repositories.VoyageurRepos;
import com.example.backend.services.interfaces.FavoriInterface;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@Transactional
public class FavoriService implements FavoriInterface {

    private static final Logger logger = LoggerFactory.getLogger(FavoriService.class);

    private FavoriMapper favoriMapper;
    private FavoriRepos favoriRepos;
    private VoyageurRepos voyageurRepos;
    private AnnoncesRepos annoncesRepos;

    public FavoriService(FavoriMapper favoriMapper,
                         FavoriRepos favoriRepos,
                         VoyageurRepos voyageurRepos,
                         AnnoncesRepos annoncesRepos) {
        this.favoriMapper = favoriMapper;
        this.favoriRepos = favoriRepos;
        this.voyageurRepos = voyageurRepos;
        this.annoncesRepos = annoncesRepos;
    }

    @Override
    public FavoriDTO ajouterFavori(FavoriDTO favoriDTO) {
        logger.info("Tentative d'ajout d'un favori");

        if (!annoncesRepos.existsById(favoriDTO.getIdAnnonce().getId())
                || !voyageurRepos.existsById(favoriDTO.getIdVoyageur().getId())) {

            logger.warn("Ajout favori refusé : annonce ou voyageur inexistant");
            throw new IllegalArgumentException(
                    "L'ID de l'annonce et l'ID du voyageur sont requis et doivent exister.");
        }

        try {
            Favori favori = favoriMapper.toEntity(favoriDTO);
            Favori savedFavori = favoriRepos.save(favori);

            logger.info("Favori ajouté avec succès (id={})", savedFavori.getId());
            return favoriMapper.toDTO(savedFavori);

        } catch (Exception e) {
            logger.error("Erreur lors de l'ajout du favori", e);
            throw new RuntimeException("Erreur lors de l'ajout du favori: " + e.getMessage());
        }
    }

    @Override
    public List<FavoriDTO> listerFavoris() {
        logger.info("Récupération de la liste des favoris");

        return favoriRepos.findAll()
                .stream()
                .map(favoriMapper::toDTO)
                .collect(Collectors.toList());
    }

    @Override
    public FavoriDTO mettreAJourFavori(Long id, FavoriDTO favoriDTO) {
        logger.info("Mise à jour du favori (id={})", id);

        Favori favori1 = favoriRepos.findById(id).orElse(null);

        if (favori1 != null) {
            try {
                favori1.setIdAnnonce(favoriDTO.getIdAnnonce());
                favori1.setIdVoyageur(favoriDTO.getIdVoyageur());

                Favori updatedFavori = favoriRepos.save(favori1);
                logger.info("Favori mis à jour avec succès (id={})", id);

                return favoriMapper.toDTO(updatedFavori);

            } catch (Exception e) {
                logger.error("Erreur lors de la mise à jour du favori (id={})", id, e);
                throw new RuntimeException("Erreur lors de la mise à jour: " + e.getMessage());
            }

        } else {
            logger.warn("Favori non trouvé pour mise à jour (id={})", id);
            throw new RuntimeException("Favori non trouvé avec l'id: " + id);
        }
    }

    @Override
    public void supprimerFavori(Long id) {
        logger.info("Suppression du favori (id={})", id);

        if (favoriRepos.existsById(id)) {
            favoriRepos.deleteById(id);
            logger.info("Favori supprimé avec succès (id={})", id);
        } else {
            logger.warn("Suppression impossible : favori non trouvé (id={})", id);
            throw new RuntimeException("Favori non trouvé avec l'id: " + id);
        }
    }

    @Override
    public FavoriDTO obtenirFavoriParId(Long id) {
        logger.info("Récupération du favori (id={})", id);

        Favori favori1 = favoriRepos.findById(id).orElse(null);

        if (favori1 != null) {
            try {
                logger.debug("Favori récupéré : {}", favori1);
                return favoriMapper.toDTO(favori1);

            } catch (Exception e) {
                logger.error("Erreur lors de la récupération du favori (id={})", id, e);
                throw new RuntimeException("Erreur: " + e.getMessage());
            }

        } else {
            logger.warn("Favori non trouvé (id={})", id);
            throw new RuntimeException("Favori non trouvé avec l'id: " + id);
        }
    }
}
package com.example.backend.services.implementations;

import com.example.backend.dto.LocalisationDTO;
import com.example.backend.entities.Localisation;
import com.example.backend.mappers.LocalisationMapper;
import com.example.backend.repositories.LocalisationRepository;
import com.example.backend.services.interfaces.LocalisationInterface;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Service permettant de gérer les opérations CRUD
 * sur l'entité Localisation.
 * Implémente LocalisationService.
 */
@Service
public class LocalisationService implements LocalisationInterface {

    /**
     * Repository pour accéder à la base de données.
     */
    
    private LocalisationRepository localisationRepository;

    /**
     * Mapper MapStruct pour convertir Entity <-> DTO.
     */
    
    private LocalisationMapper localisationMapper;

    public LocalisationService(LocalisationRepository localisationRepository, LocalisationMapper localisationMapper) {
        this.localisationRepository = localisationRepository;
        this.localisationMapper = localisationMapper;
    }

    /**
     * Enregistre une nouvelle localisation.
     *
     * @param localisationDTO DTO contenant les données.
     * @return DTO de la localisation sauvegardée.
     */
    @Override
    public LocalisationDTO save(LocalisationDTO localisationDTO) {
        Localisation localisation = localisationMapper.toEntity(localisationDTO);
        Localisation saved = localisationRepository.save(localisation);
        return localisationMapper.toDto(saved);
    }

    /**
     * Retourne la liste de toutes les localisations.
     */
    @Override
    public List<LocalisationDTO> getAll() {
        return localisationRepository.findAll().stream().map(
        localisationMapper::toDto).collect(Collectors.toList());
    }

    /**
     * Recherche une localisation par son id.
     */
    @Override
    public LocalisationDTO getById(Long id) {
        Localisation localisation = localisationRepository.findById(id).get();
        if (localisation == null){
            throw new RuntimeException("Localisation non trouvée");
        }else {
        return localisationMapper.toDto(localisation);
    }
    }

    /**
     * Supprime une localisation selon son id.
     */
        @Override
        public void delete(Long id) {
            localisationRepository.deleteById(id);

        }

    /**
     * Met à jour une localisation existante.
     *
     * @param id identifiant de la localisation à modifier
     * @param localisationDTO nouvelle valeur
     * @return localisation mise à jour
     */
    @Override
    public LocalisationDTO update(Long id, LocalisationDTO localisationDTO) {
        // Convertir le DTO en entité
        Localisation localisation = localisationMapper.toEntity(localisationDTO);

        // Assigner l’ID existant
        localisation.setId(id);

        // Sauvegarder les modifications
        Localisation updated = localisationRepository.save(localisation);

        // Retourner le résultat au format DTO
        return localisationMapper.toDto(updated);
    }



    }




package com.example.backend.services.implementations;

import com.example.backend.dto.NotificationDTO;
import com.example.backend.entities.Notification;
import com.example.backend.entities.Utilisateur;
import com.example.backend.mappers.NotificationMapper;
import com.example.backend.repositories.NotificationRepository;
import com.example.backend.repositories.UtilisateurRepository;
import com.example.backend.services.interfaces.NotificationInterface;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Service de gestion des notifications avec opérations CRUD
 * @author Lumiere NGO NGWA
 */
@Service
@Transactional
public class NotificationService implements NotificationInterface {
    private NotificationRepository notificationRepository;
    private UtilisateurRepository utilisateurRepository;
    private NotificationMapper  notificationMapper;

    public NotificationService(NotificationRepository notificationRepository, UtilisateurRepository utilisateurRepository, NotificationMapper notificationMapper) {
        this.notificationRepository = notificationRepository;
        this.utilisateurRepository = utilisateurRepository;
        this.notificationMapper = notificationMapper;
    }

    @Override
    public NotificationDTO creerNotification(NotificationDTO notificationDTO) {
        if (notificationDTO.getId() == null || notificationDTO.getTitre() == null || notificationDTO.getMessage()== null || !utilisateurRepository.existsById(notificationDTO.getIdUser().getId())) {
            throw new IllegalArgumentException("donnee invalide");
        }else {
            try{
                return notificationMapper.toDTO(notificationRepository.save(notificationMapper.toEntity(notificationDTO)));
            } catch (Exception e) {
                throw e;
            }
        }
    }


    // ================== READ ==================

    @Override
    public List<NotificationDTO> obtenirToutesLesNotifications() {
        return notificationRepository.findAll()
                .stream()
                .map(notificationMapper::toDTO)
                .collect(Collectors.toList());
    }

    @Override
    public Optional<NotificationDTO> obtenirNotificationParId(Long id) {
        return notificationRepository.findById(id)
                .map(notificationMapper::toDTO);
    }

    @Override
    public List<NotificationDTO> obtenirNotificationsParUtilisateur(Long idUser) {
        if (!utilisateurRepository.existsById(idUser)) {
            throw new IllegalArgumentException("Utilisateur inexistant");
        }

        return notificationRepository.findByIdUser(utilisateurRepository.findById(idUser).get())
                .stream()
                .map(notificationMapper::toDTO)
                .collect(Collectors.toList());
    }

    @Override
    public List<NotificationDTO> obtenirNotificationsNonLues(Long idUser) {
        if (!utilisateurRepository.existsById(idUser)) {
            throw new IllegalArgumentException("Utilisateur inexistant");
        }

        return notificationRepository.findByIdUserIdAndEstLueFalse(idUser)
                .stream()
                .map(notificationMapper::toDTO)
                .collect(Collectors.toList());
    }

    @Override
    public Long compterNotificationsNonLues(Long idUser) {
        if (!utilisateurRepository.existsById(idUser)) {
            throw new IllegalArgumentException("Utilisateur inexistant");
        }

        return notificationRepository.countByIdUserIdAndEstLueFalse(idUser);
    }

    // ================== UPDATE ==================

    @Override
    public NotificationDTO marquerCommeLue(Long id) {
        Notification notification = notificationRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Notification introuvable"));

        notification.setLue(true);
        return notificationMapper.toDTO(notificationRepository.save(notification));
    }

    @Override
    public void marquerToutesCommeLues(Long idUser) {
        if (!utilisateurRepository.existsById(idUser)) {
            throw new IllegalArgumentException("Utilisateur inexistant");
        }

        List<Notification> notifications =
                notificationRepository.findByIdUserIdAndEstLueFalse(idUser);

        notifications.forEach(n -> n.setLue(true));
        notificationRepository.saveAll(notifications);
    }

    @Override
    public NotificationDTO mettreAJourNotification(Long id, NotificationDTO notificationDTO) {
        Notification notification = notificationRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Notification introuvable"));

        if (notificationDTO.getTitre() != null) {
            notification.setTitre(notificationDTO.getTitre());
        }
        if (notificationDTO.getMessage() != null) {
            notification.setMessage(notificationDTO.getMessage());
        }

        return notificationMapper.toDTO(notificationRepository.save(notification));
    }

    // ================== DELETE ==================

    @Override
    public void supprimerNotification(Long id) {
        if (!notificationRepository.existsById(id)) {
            throw new IllegalArgumentException("Notification introuvable");
        }
        notificationRepository.deleteById(id);
    }

    @Override
    public void supprimerToutesLesNotificationsUtilisateur(Long idUser) {
        if (!utilisateurRepository.existsById(idUser)) {
            throw new IllegalArgumentException("Utilisateur inexistant");
        }
        notificationRepository.deleteByIdUserId(idUser);
    }
}
package com.example.backend.services.implementations;

import com.example.backend.dto.PaiementDTO;
import com.example.backend.entities.Paiement;
import com.example.backend.entities.Reservation;
import com.example.backend.repositories.PaiementRepository;
import com.example.backend.repositories.ReservationRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * Service pour la gestion des paiements
 * @author Wulfrid MBONGO
 */
@Service
@Transactional
public class PaiementService {

    @Autowired
    private PaiementRepository paiementRepository;

    @Autowired
    private ReservationRepository reservationRepository;

    /**
     * Crée un nouveau paiement
     */
    public PaiementDTO creerPaiement(PaiementDTO paiementDTO) {
        // Validation
        if (paiementDTO.getMontant() == null || paiementDTO.getMontant() <= 0) {
            throw new IllegalArgumentException("Le montant doit être positif");
        }

        if (paiementDTO.getIdReservation() == null) {
            throw new IllegalArgumentException("La réservation est obligatoire");
        }

        // Vérifier que la réservation existe
        Reservation reservation = reservationRepository.findById(paiementDTO.getIdReservation())
                .orElseThrow(() -> new IllegalArgumentException("Réservation introuvable avec l'ID: " + paiementDTO.getIdReservation()));

        // Créer le paiement
        Paiement paiement = new Paiement();
        paiement.setMontant(paiementDTO.getMontant());
        paiement.setMethode(paiementDTO.getMethode());
        paiement.setStatut(paiementDTO.getStatut() != null ? paiementDTO.getStatut() : "EN_ATTENTE");
        paiement.setIdReservation(reservation);

        // Générer un ID de transaction unique si non fourni
        if (paiementDTO.getIdTransaction() == null || paiementDTO.getIdTransaction().isEmpty()) {
            paiement.setIdTransaction("TXN-" + UUID.randomUUID().toString());
        } else {
            paiement.setIdTransaction(paiementDTO.getIdTransaction());
        }

        paiement.setUrlRecepisse(paiementDTO.getUrlRecepisse());

        // Sauvegarder
        Paiement paiementSauvegarde = paiementRepository.save(paiement);

        return convertirEnDTO(paiementSauvegarde);
    }

    /**
     * Récupère tous les paiements
     */
    @Transactional(readOnly = true)
    public List<PaiementDTO> obtenirTousLesPaiements() {
        return paiementRepository.findAll().stream()
                .map(this::convertirEnDTO)
                .collect(Collectors.toList());
    }

    /**
     * Récupère un paiement par son ID
     */
    @Transactional(readOnly = true)
    public PaiementDTO obtenirPaiementParId(Long id) {
        Paiement paiement = paiementRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Paiement introuvable avec l'ID: " + id));
        return convertirEnDTO(paiement);
    }

    /**
     * Récupère tous les paiements d'une réservation
     */
    @Transactional(readOnly = true)
    public List<PaiementDTO> obtenirPaiementsParReservation(Long idReservation) {
        return paiementRepository.findByIdReservation_Id(idReservation).stream()
                .map(this::convertirEnDTO)
                .collect(Collectors.toList());
    }

    /**
     * Récupère un paiement par son ID de transaction
     */
    @Transactional(readOnly = true)
    public PaiementDTO obtenirPaiementParIdTransaction(String idTransaction) {
        Paiement paiement = paiementRepository.findByIdTransaction(idTransaction)
                .orElseThrow(() -> new IllegalArgumentException("Paiement introuvable avec l'ID de transaction: " + idTransaction));
        return convertirEnDTO(paiement);
    }

    /**
     * Récupère tous les paiements par statut
     */
    @Transactional(readOnly = true)
    public List<PaiementDTO> obtenirPaiementsParStatut(String statut) {
        return paiementRepository.findByStatut(statut).stream()
                .map(this::convertirEnDTO)
                .collect(Collectors.toList());
    }

    /**
     * Met à jour un paiement
     */
    public PaiementDTO mettreAJourPaiement(Long id, PaiementDTO paiementDTO) {
        Paiement paiement = paiementRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Paiement introuvable avec l'ID: " + id));

        // Mise à jour des champs modifiables
        if (paiementDTO.getMontant() != null && paiementDTO.getMontant() > 0) {
            paiement.setMontant(paiementDTO.getMontant());
        }

        if (paiementDTO.getStatut() != null && !paiementDTO.getStatut().isEmpty()) {
            paiement.setStatut(paiementDTO.getStatut());
        }

        if (paiementDTO.getUrlRecepisse() != null) {
            paiement.setUrlRecepisse(paiementDTO.getUrlRecepisse());
        }

        if (paiementDTO.getMethode() != null && !paiementDTO.getMethode().isEmpty()) {
            paiement.setMethode(paiementDTO.getMethode());
        }

        // Sauvegarder
        Paiement paiementMisAJour = paiementRepository.save(paiement);

        return convertirEnDTO(paiementMisAJour);
    }

    /**
     * Met à jour le statut d'un paiement
     */
    public PaiementDTO mettreAJourStatutPaiement(Long id, String nouveauStatut) {
        Paiement paiement = paiementRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("Paiement introuvable avec l'ID: " + id));

        paiement.setStatut(nouveauStatut);
        Paiement paiementMisAJour = paiementRepository.save(paiement);

        return convertirEnDTO(paiementMisAJour);
    }

    /**
     * Supprime un paiement
     */
    public void supprimerPaiement(Long id) {
        if (!paiementRepository.existsById(id)) {
            throw new IllegalArgumentException("Paiement introuvable avec l'ID: " + id);
        }
        paiementRepository.deleteById(id);
    }

    /**
     * Calcule le montant total payé pour une réservation
     */
    @Transactional(readOnly = true)
    public Double calculerMontantTotalPaye(Long idReservation) {
        Double montantTotal = paiementRepository.sumMontantByReservationAndStatut(idReservation, "VALIDE");
        return montantTotal != null ? montantTotal : 0.0;
    }

    /**
     * Vérifie si une réservation est entièrement payée
     */
    @Transactional(readOnly = true)
    public boolean estEntierementPaye(Long idReservation) {
        Reservation reservation = reservationRepository.findById(idReservation)
                .orElseThrow(() -> new IllegalArgumentException("Réservation introuvable avec l'ID: " + idReservation));

        Double montantPaye = calculerMontantTotalPaye(idReservation);
        Double prixTotal = reservation.getPrixTotal();

        return prixTotal != null && montantPaye >= prixTotal;
    }

    /**
     * Convertit une entité Paiement en DTO
     */
    private PaiementDTO convertirEnDTO(Paiement paiement) {
        PaiementDTO dto = new PaiementDTO();
        dto.setId(paiement.getId());
        dto.setMontant(paiement.getMontant());
        dto.setIdTransaction(paiement.getIdTransaction());
        dto.setUrlRecepisse(paiement.getUrlRecepisse());
        dto.setMethode(paiement.getMethode());
        dto.setStatut(paiement.getStatut());

        if (paiement.getIdReservation() != null) {
            dto.setIdReservation(paiement.getIdReservation().getId());
            dto.setCodeConfirmationReservation(paiement.getIdReservation().getCodeConfirmation());

            if (paiement.getIdReservation().getIdVoyageur() != null
                    && paiement.getIdReservation().getIdVoyageur().getIdUser() != null) {
                String nomComplet = paiement.getIdReservation().getIdVoyageur().getIdUser().getPrenom()
                        + " " + paiement.getIdReservation().getIdVoyageur().getIdUser().getNom();
                dto.setNomVoyageur(nomComplet);
            }
        }

        return dto;
    }
}package com.example.backend.services.implementations;

import com.example.backend.dto.AnnonceDTO;
import com.example.backend.entities.Annonces;
import com.example.backend.entities.Disponibilite;
import com.example.backend.entities.Reservation;
import com.example.backend.entities.Voyageur;
import com.example.backend.dto.DisponibiliteRequestDTO;
import com.example.backend.dto.ReservationRequestDTO;
import com.example.backend.dto.ReservationResponseDTO;
import com.example.backend.repositories.DisponibiliteRepository;
import com.example.backend.services.interfaces.ReservationServiceInterface;
import com.example.backend.repositories.AnnoncesRepository;
import com.example.backend.repositories.ReservationRepository;
import com.example.backend.repositories.VoyageurRepository;
import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDate;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;
import java.util.Date;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@Transactional



public class ReservationService implements ReservationServiceInterface {
    @Autowired
    private ReservationRepository reservationRepository;
    @Autowired
    private AnnoncesRepository annoncesRepository;
    @Autowired
    private VoyageurRepository voyageurRepository;
    @Autowired
    DisponibiliteRepository disponibiliteRepository;



    @Override
    public boolean verifierDisponibilite(DisponibiliteRequestDTO request) {
        // 1. Vérifier que l'annonce existe et est active
        Annonces annonce = annoncesRepository.findById(request.getAnnonceId())
                .orElseThrow(() -> new RuntimeException("Annonce non trouvée"));
        if(!annonce.getEstActive()) {
            return false;
        }
        // 2. vérifier les dates

        if(request.getDateDebut().isAfter(request.getDateFin())) {
            throw new RuntimeException("Date de début après la date de fin");
        }

        if(request.getDateDebut().isBefore(LocalDate.now())) {
            throw new RuntimeException("date déjà passé");
        }
        // 3. Vérifier le nombre d'invités

        if(request.getNombreInvites()>annonce.getMaxInvites()){
            return  false;
        }

        // Convertir LocalDate en Date
        Date dateDebut = Date.from(request.getDateDebut().atStartOfDay(ZoneId.systemDefault()).toInstant());
        Date dateFin = Date.from(request.getDateFin().atStartOfDay(ZoneId.systemDefault()).toInstant());

       // 4. vérifier qu'il existe une disponubilité qui couvre la période

        List<Disponibilite>disponibilites=disponibiliteRepository.findDisponibiliteCouvrante(request.getAnnonceId(),dateDebut,dateFin);
        if(disponibilites.isEmpty()){
            return  false;
        }

        // 5. Vérifier qu'il n'y a pas de période bloquée
        List<Disponibilite> periodesBloquees = disponibiliteRepository
                .findPeriodesBloquees(request.getAnnonceId(), dateDebut, dateFin);

        if (!periodesBloquees.isEmpty()) {
            return false;
        }

        // 6 vérifier qu'il n'y a pas de réservation chevauchante
        List<Reservation>reservationsChevaucahntes=reservationRepository.findReservationsChevauchantes(request.getAnnonceId(),dateDebut,dateFin);
        return   reservationsChevaucahntes.isEmpty();
    }

    @Override
    public ReservationResponseDTO creerReservation(ReservationRequestDTO request) {

        DisponibiliteRequestDTO dispoCheck=new DisponibiliteRequestDTO(
                request.getAnnonceId(),
                request.getDateDebut(),
                request.getDateFin(),
                request.getNombreInvites()
        );
        if(!verifierDisponibilite(dispoCheck)) {
            throw new RuntimeException("anonces non disponible");


        }

        //recuperer l'annonce et le voyageur
        Annonces annonce=annoncesRepository.findById(request.getAnnonceId())
                .orElseThrow(()->new RuntimeException("Annonce non trouvée"));

        Voyageur voyageur=voyageurRepository.findById(request.getVoyageurId())
                .orElseThrow(()->new RuntimeException("Voyageur non disponible"));

        //caluculer le prix total
        long nombreNuits = ChronoUnit.DAYS.between(request.getDateDebut(), request.getDateFin());
        Double prixTotal = nombreNuits * annonce.getPrix();

        // Générer un code de confirmation
        String codeConfirmation = "RES-" + UUID.randomUUID().toString().substring(0, 8).toUpperCase();
        // Créer la réservation
        Reservation reservation = new Reservation();
        reservation.setAnnonce(annonce);
        reservation.setIdVoyageur(voyageur);
        reservation.setDateDebut(Date.from(request.getDateDebut().atStartOfDay(ZoneId.systemDefault()).toInstant()));
        reservation.setDateFin(Date.from(request.getDateFin().atStartOfDay(ZoneId.systemDefault()).toInstant()));
        reservation.setNombreInvites(request.getNombreInvites());
        reservation.setPrixTotal(prixTotal);
        reservation.setCodeConfirmation(codeConfirmation);
        reservation.setStatut("EN_ATTENTE");

        reservation = reservationRepository.save(reservation);

        return convertirEnDTO(reservation);
    }

    @Override
    public ReservationResponseDTO obtenirReservation(Long id) {
        Reservation reservation = reservationRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Réservation non trouvée"));

        return convertirEnDTO(reservation);
    }



    @Override
    public List<ReservationResponseDTO> obtenirReservationsVoyageur(Long voyageurId) {
        List<Reservation> reservations = reservationRepository.findByIdVoyageur_IdOrderByDateDebutDesc(voyageurId);

        return reservations.stream()
                .map(this::convertirEnDTO)
                .collect(Collectors.toList());
    }




    @Override
    public ReservationResponseDTO annulerReservation(Long id) {
        Reservation reservation = reservationRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Réservation non trouvée"));

        if ("TERMINEE".equals(reservation.getStatut())) {
            throw new RuntimeException("Impossible d'annuler une réservation terminée");
        }

        reservation.setStatut("ANNULEE");
        reservation = reservationRepository.save(reservation);

        return convertirEnDTO(reservation);
    }

    @Override
    public ReservationResponseDTO confirmerReservation(Long id) {
        Reservation reservation = reservationRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Réservation non trouvée"));

        if (!"EN_ATTENTE".equals(reservation.getStatut())) {
            throw new RuntimeException("Seules les réservations en attente peuvent être confirmées");
        }

        reservation.setStatut("CONFIRMEE");
        reservation = reservationRepository.save(reservation);

        return convertirEnDTO(reservation);
    }
    @Override
    public ReservationResponseDTO obtenirParCodeConfirmation(String code) {
        Reservation reservation = reservationRepository.findByCodeConfirmation(code)
                .orElseThrow(() -> new RuntimeException("Réservation non trouvée"));

        return convertirEnDTO(reservation);
    }

    @Override
        public List<ReservationResponseDTO> obtenirTouteResvervation() {
            return reservationRepository.findAll()
                    .stream()
                    .map(this::convertirEnDTO)
                    .collect(Collectors.toList());
        }


    // Méthode utilitaire pour convertir Reservation en DTO
    private ReservationResponseDTO convertirEnDTO(Reservation reservation) {
        ReservationResponseDTO dto = new ReservationResponseDTO();

        dto.setId(reservation.getId());
        dto.setCodeConfirmation(reservation.getCodeConfirmation());
        dto.setNombreInvites(reservation.getNombreInvites());
        dto.setPrixTotal(reservation.getPrixTotal());
        dto.setStatut(reservation.getStatut());

        // Infos de l'annonce
        dto.setAnnonceId(reservation.getAnnonce().getId());


        // Infos du voyageur
        dto.setVoyageurId(reservation.getIdVoyageur().getId());

        return dto;
    }
}

package com.example.backend.services.implementations;

import com.example.backend.dto.SignalementRequestDTO;
import com.example.backend.entities.Admin;
import com.example.backend.entities.Annonces;
import com.example.backend.entities.Signalement;
import com.example.backend.entities.Utilisateur;
import com.example.backend.exceptions.ResourceNotFoundException;
import com.example.backend.repositories.AdminRepository;
import com.example.backend.repositories.AnnoncesRepository;
import com.example.backend.repositories.UtilisateurRepository;
import com.example.backend.repositories.SignalementRepository;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class SignalementService {

    private final SignalementRepository signalementRepository;
    private final AnnoncesRepository annoncesRepository;
    private final AdminRepository adminRepository;


    public SignalementService(
            SignalementRepository signalementRepository,
            AnnoncesRepository annoncesRepository,AdminRepository adminRepository) {
        this.signalementRepository = signalementRepository;
        this.annoncesRepository = annoncesRepository;
        this.adminRepository=adminRepository;

    }
    public Signalement creer(SignalementRequestDTO dto) {

        Annonces annonce = annoncesRepository.findById(dto.getAnnonceId())
                .orElseThrow(() -> new RuntimeException("Annonce non trouvée"));

        Admin admin = adminRepository.findById(dto.getAdminId())
                .orElseThrow(() -> new RuntimeException("Admin introuvable"));


        Signalement s = new Signalement();
        s.setRaison(dto.getRaison());
        s.setDescription(dto.getDescription());
        s.setStatut("EN_ATTENTE");
        s.setIdAdmin(admin);
        s.setIdAnnonce(annonce);

        return signalementRepository.save(s);
    }

    // READ ALL
    public List<Signalement> getAll() {
        return signalementRepository.findAll();
    }

    // READ ONE
    public Signalement getById(Long id) {
        return signalementRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Signalement non trouvé"));
    }

    // UPDATE
    public Signalement traiter(Long id, String statut, String resolution) {
        Signalement s = getById(id);
        s.setStatut(statut);
        s.setResolution(resolution);
        return signalementRepository.save(s);
    }

    // DELETE
    public void supprimer(Long id) {
        signalementRepository.deleteById(id);
    }
}
package com.example.backend.services.implementations;

import com.example.backend.dto.UtilisateurDTO;
import com.example.backend.entities.Utilisateur;
import com.example.backend.mappers.UtilisateurMapper;
import com.example.backend.repositories.UtilisateurRepository;
import com.example.backend.services.interfaces.UtilisateurInterface;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class UtilisateurService implements UtilisateurInterface {

    private static final Logger logger = LoggerFactory.getLogger(UtilisateurService.class);

    private UtilisateurRepository repository;
    private PasswordEncoder passwordEncoder;
    private UtilisateurMapper utilisateurMapper;

    public UtilisateurService(UtilisateurRepository repository,
                              PasswordEncoder passwordEncoder,
                              UtilisateurMapper utilisateurMapper) {
        this.repository = repository;
        this.passwordEncoder = passwordEncoder;
        this.utilisateurMapper = utilisateurMapper;
    }

    @Override
    public List<UtilisateurDTO> getAllUtilisateurs() {
        logger.info("Récupération de la liste des utilisateurs");

        return repository.findAll()
                .stream()
                .map(utilisateurMapper::toDTO)
                .collect(Collectors.toList());
    }

    @Override
    public UtilisateurDTO getUtilisateurById(Long id) {
        logger.info("Récupération de l'utilisateur (id={})", id);

        try {
            Utilisateur utilisateur = repository.findById(id).get();
            logger.debug("Utilisateur récupéré : {}", utilisateur);

            return utilisateurMapper.toDTO(utilisateur);

        } catch (Exception e) {
            logger.warn("Utilisateur non trouvé (id={})", id);
            throw new RuntimeException("Utilisateur non trouvé avec l'id: " + id);
        }
    }

    @Override
    public UtilisateurDTO createUtilisateur(UtilisateurDTO utilisateurDTO) {
        logger.info("Création d'un nouvel utilisateur (email={})", utilisateurDTO.getEmail());

        if (repository.existsByEmail(utilisateurDTO.getEmail())) {
            logger.warn("Création utilisateur refusée : email déjà utilisé ({})", utilisateurDTO.getEmail());
            throw new RuntimeException("Email déjà utilisé");
        }

        try {
            utilisateurDTO.setMotDePasse(
                    passwordEncoder.encode(utilisateurDTO.getMotDePasse())
            );

            Utilisateur savedUtilisateur =
                    repository.save(utilisateurMapper.toEntity(utilisateurDTO));

            logger.info("Utilisateur créé avec succès (id={})", savedUtilisateur.getId());
            return utilisateurMapper.toDTO(savedUtilisateur);

        } catch (Exception e) {
            logger.error("Erreur lors de la création de l'utilisateur", e);
            throw new RuntimeException("Erreur lors de la création de l'utilisateur: " + e.getMessage());
        }
    }

    @Override
    public UtilisateurDTO updateUtilisateur(Long id, UtilisateurDTO utilisateurDTO) {
        logger.info("Mise à jour de l'utilisateur (id={})", id);

        try {
            Utilisateur existingUtilisateur = repository.findById(id).get();

            if (existingUtilisateur == null) {
                logger.warn("Utilisateur non trouvé pour mise à jour (id={})", id);
                throw new RuntimeException("Utilisateur non trouvé avec l'id: " + id);
            }

            existingUtilisateur.setNom(utilisateurDTO.getNom());
            existingUtilisateur.setPrenom(utilisateurDTO.getPrenom());
            existingUtilisateur.setEmail(utilisateurDTO.getEmail());
            existingUtilisateur.setRole(utilisateurDTO.getRole());

            repository.save(existingUtilisateur);
            logger.info("Utilisateur mis à jour avec succès (id={})", id);

            return utilisateurMapper.toDTO(existingUtilisateur);

        } catch (Exception e) {
            logger.error("Erreur lors de la mise à jour de l'utilisateur (id={})", id, e);
            throw new RuntimeException("Erreur lors de la mise à jour de l'utilisateur: " + e.getMessage());
        }
    }

    @Override
    public void deleteUtilisateur(Long id) {
        logger.info("Suppression de l'utilisateur (id={})", id);

        if (!repository.existsById(id)) {
            logger.warn("Suppression impossible : utilisateur non trouvé (id={})", id);
            throw new RuntimeException("Utilisateur non trouvé avec l'id: " + id);
        }

        repository.deleteById(id);
        logger.info("Utilisateur supprimé avec succès (id={})", id);
    }
}
